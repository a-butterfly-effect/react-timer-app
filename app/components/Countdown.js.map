{"version":3,"sources":["Countdown.jsx"],"names":[],"mappings":";;AAAA,IAAI,QAAQ,QAAQ,OAAR,CAAZ;AACA,IAAI,QAAQ,QAAQ,OAAR,CAAZ;AACA,IAAI,gBAAgB,QAAQ,eAAR,CAApB;AACA,IAAI,WAAW,QAAQ,UAAR,CAAf;;AAEA,IAAI,YAAY,MAAM,WAAN,CAAkB;AAAA;;AAC9B,qBAAoB,2BAAY;AAC5B,eAAO;AACH,mBAAiB,CADd;AAEH,6BAAiB;AAFd,SAAP;AAIH,KAN6B;AAO9B;AACA;AACA,wBAAoB,8BAAY;AAC5B,gBAAQ,GAAR,CAAY,oBAAZ;AACH,KAX6B;AAY9B;AACA;AACA,uBAAoB,6BAAY;AAC5B,gBAAQ,GAAR,CAAY,mBAAZ;AACH,KAhB6B;AAiB9B;AACA;AACA,yBAAsB,6BAAU,SAAV,EAAqB,SAArB,EAAgC,CAErD,CArB6B;AAsB9B;AACA;AACA,wBAAsB,4BAAU,SAAV,EAAqB,SAArB,EAAgC;AAClD,YAAI,KAAK,KAAL,CAAW,eAAX,KAA+B,UAAU,eAA7C,EAA8D;AAC1D,oBAAQ,KAAK,KAAL,CAAW,eAAnB;AACI,qBAAK,SAAL;AACI,yBAAK,UAAL;AACA;AACJ;AACA;AACA,qBAAK,SAAL;AACI,yBAAK,QAAL,CAAc,EAAC,OAAO,CAAR,EAAd;AACJ;AACA,qBAAK,QAAL;AACI,kCAAc,KAAK,KAAnB;AACA,yBAAK,KAAL,GAAa,SAAb;AACA;AAZR;AAcH;AACJ,KAzC6B;AA0C9B;AACA;AACA,0BAAsB,gCAAY;AAC9B,gBAAQ,GAAR,CAAY,sBAAZ;AACA;AACA,sBAAc,KAAK,KAAnB;AACA,aAAK,KAAL,GAAa,SAAb;AACH,KAjD6B;AAkD9B;AACA,gBAAsB,sBAAY;AAAA;;AAC9B;AACA;AACA;AACA;AACA;AACA,aAAK,KAAL,GAAa,YAAY,YAAM;AAC3B,gBAAI,WAAW,MAAK,KAAL,CAAW,KAAX,GAAmB,CAAlC;AACA,kBAAK,QAAL,CAAc;AACV,uBAAO,YAAY,CAAZ,GAAgB,QAAhB,GAA2B;AADxB,aAAd;;AAIA;AACA,gBAAI,aAAa,CAAjB,EAAoB;AAChB,sBAAK,QAAL,CAAc;AACV,qCAAkB;AADR,iBAAd;AAGH;AACJ,SAZY,EAYV,IAZU,CAAb;AAaH,KAtE6B;AAuE9B,wBAAsB,4BAAU,OAAV,EAAmB;AACrC,aAAK,QAAL,CAAc;AACV,mBAAiB,OADP;AAEV,6BAAiB;AAFP,SAAd;AAIH,KA5E6B;AA6E9B;AACA,wBAAsB,4BAAU,SAAV,EAAqB;AACvC,aAAK,QAAL,CAAc;AACV,6BAAiB;AADP,SAAd;AAGH,KAlF6B;AAmF9B,YAAsB,kBAAY;AAAA;;AAAA,qBACC,KAAK,KADN;AAAA,YACzB,KADyB,UACzB,KADyB;AAAA,YAClB,eADkB,UAClB,eADkB;;AAG9B;;AACA,YAAI,oBAAoB,SAApB,iBAAoB,GAAM;AAC1B,gBAAI,oBAAoB,SAAxB,EAAmC;AAC/B;AACA,uBAAO,oBAAC,QAAD,IAAU,iBAAiB,eAA3B;AACU,oCAAgB,OAAK,kBAD/B,GAAP;AAEH,aAJD,MAIO;AACH;AACA;AACA;AACA;AACA,uBAAO,oBAAC,aAAD,IAAe,gBAAgB,OAAK,kBAApC,GAAP;AACH;AACJ,SAZD;;AAcA,eACI;AAAA;AAAA;AACI,gCAAC,KAAD,IAAO,cAAc,KAArB,GADJ;AAEK;AAFL,SADJ;AAMH;AA3G6B,CAAlB,CAAhB;;AA8GA,OAAO,OAAP,GAAiB,SAAjB","file":"Countdown.js","sourcesContent":["let React = require('react');\r\nlet Clock = require('Clock');\r\nlet CountdownForm = require('CountdownForm');\r\nlet Controls = require('Controls');\r\n\r\nlet Countdown = React.createClass({\r\n    getInitialState   : function () {\r\n        return {\r\n            count          : 0,\r\n            countdownStatus: 'stopped'\r\n        };\r\n    },\r\n    // Will get fired as our component gets first mounted\r\n    // Means that we don't have access to the refs or the DOM\r\n    componentWillMount: function () {\r\n        console.log('componentWillMount');\r\n    },\r\n    // Gets fired right after everything gets rendered in the DOM\r\n    // This means that we will have access to any refs\r\n    componentDidMount : function () {\r\n        console.log('componentDidMount');\r\n    },\r\n    // Gets fired before the fact\r\n    // Gets passed on the next props and the next state\r\n    componentWillUpdate : function (nextProps, nextState) {\r\n\r\n    },\r\n    // Lifecycle methods !!!\r\n    // Gets fired right after either props or state get updated\r\n    componentDidUpdate  : function (prevProps, prevState) {\r\n        if (this.state.countdownStatus !== prevState.countdownStatus) {\r\n            switch (this.state.countdownStatus) {\r\n                case 'started':\r\n                    this.startTimer();\r\n                    break;\r\n                // When stopped we reset the count and also cancel the set interval\r\n                // Which means we have a fallthrough and it is acceptable in this case\r\n                case 'stopped':\r\n                    this.setState({count: 0});\r\n                // In contrast to paused where we just cancel the set interval\r\n                case 'paused':\r\n                    clearInterval(this.timer);\r\n                    this.timer = undefined;\r\n                    break;\r\n            }\r\n        }\r\n    },\r\n    // Automatically gets fired by React right before our component gets removed from the DOM\r\n    // In this case will get fired when we click at the menu links\r\n    componentWillUnmount: function () {\r\n        console.log('componentWillUnmount');\r\n        // Stop the interval\r\n        clearInterval(this.timer);\r\n        this.timer = undefined;\r\n    },\r\n    // Start the timer\r\n    startTimer          : function () {\r\n        // Trigger a function once after a certain amount of time\r\n        // setTimeout();\r\n        // Keep triggering a function every interval\r\n        // Give access to the variable so we can clear it later the user clicks pause\r\n        // or when they click the clear button\r\n        this.timer = setInterval(() => {\r\n            let newCount = this.state.count - 1;\r\n            this.setState({\r\n                count: newCount >= 0 ? newCount : 0\r\n            });\r\n\r\n            // If we have reached the end of the countdown then there is no reason to keep the timer around\r\n            if (newCount === 0) {\r\n                this.setState({\r\n                    countdownStatus : 'stopped'\r\n                });\r\n            }\r\n        }, 1000);\r\n    },\r\n    handleSetCountdown  : function (seconds) {\r\n        this.setState({\r\n            count          : seconds,\r\n            countdownStatus: 'started'\r\n        });\r\n    },\r\n    //\r\n    handleStatusChange  : function (newStatus) {\r\n        this.setState({\r\n            countdownStatus: newStatus\r\n        });\r\n    },\r\n    render              : function () {\r\n        let {count, countdownStatus} = this.state;\r\n\r\n        // When we want to dynamically render something we have to a use a function\r\n        let renderControlArea = () => {\r\n            if (countdownStatus !== 'stopped') {\r\n                // If not stopped render the controls\r\n                return <Controls countdownStatus={countdownStatus}\r\n                                 onStatusChange={this.handleStatusChange}/>\r\n            } else {\r\n                // If stopped render the countdown form\r\n                // Pass down a function as a prop, we can wait for actions to get fired on the children\r\n                // and then do something with those\r\n                // Which is why we don't call it here\r\n                return <CountdownForm onSetCountdown={this.handleSetCountdown}/>\r\n            }\r\n        };\r\n\r\n        return (\r\n            <div>\r\n                <Clock totalSeconds={count}/>\r\n                {renderControlArea()}\r\n            </div>\r\n        );\r\n    }\r\n});\r\n\r\nmodule.exports = Countdown;"]}